<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>184 HW4</title>
    <style>
        h1 {
            text-align: center;
        }
        h2 {
            text-align: center;
        }
        h3 {
            text-align: center;
        }
        .solo-image {
            max-width: 45%; 
            display: block;
            margin-left: auto;
            margin-right: auto;
        }
        .image-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            margin-bottom: 10px;
        }
        .image-container img {
            max-width: 100%; 
       
            margin: 10px; 
        }
        .image-container figcaption {
            text-align: center;
            width: 100%; 
        }
        .image-container figure {
            display: inline-block;
            max-width: 45%; 
            margin: 10px;
        }
        figure{
            display: inline-block;
        }
                
    </style>
</head>
<body>
    <header>
        <h1>CS184 Homework 4: Cloth Sim</h1>
        <h2>Andres Avella and Andrew Nguyen</h2>
        <a href="https://cal-cs184-student.github.io/hw-webpages-sp24-andrewn3672/hw4/index.html">https://cal-cs184-student.github.io/hw-webpages-sp24-andrewn3672/hw4/index.html</a>
        <nav>
            <ul>
                <li><a href="#overview">Overview</a></li>
                <li><a href="#section1">Part 1: Masses and Springs</a></li>
                <li><a href="#section2">Part 2: Simulation via Numerical Integration</a></li>
                <li><a href="#section3">Part 3: Handling Collisions With Other Objects</a></li>
                <li><a href="#section4">Part 4: Handling Self-Collisions</a></li>
                <li><a href="#section5">Part 5: Shaders</a></li>
                <li><a href="#collab">Collaboration</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section id="overview">
            <h2>Overview</h2>
            <p>
                In this assignment, we explored how to implement a pathtracer and the fundamentals of ray tracing. In part 1, we implemented ray generation and scene intersection. In ray generation, we though about it in terms of how view rays in world space and camera space. Given an x and y, we calculate its corresponding x and y in camera space. We then put these x and y into a Vector3D with the z value being -1. We can create a ray with the Vector3D converted to world space to get a ray in world space. To then raytrace a pixel, we iterate over a given number of samples. We first get a sample from the grid sampler and scale the x and y of the point appropriately. We then call our previous generate_ray function and add it’s global illumination to a total. We then normalized this by dividing this sum by the total samples we took to get the color of the pixel. To check for what the generated ray intersects in the scene, we had to implement intersections with the primitives. This this case the primitives were either spheres or triangles. For the triangle, we implemented the Moller Trumbore Algorithm since it is more optimized then simply checking for an intersection and doing line tests. We did a similar thing for the sphere using another algorithm. One issue we have however is that when we check the intersection for rays, we are checking with every primitive, this is extremely slow so we implement an optimization in part 2. This optimization is BVHacceleration. To construct the BVH (Bounding Volume Hierarchy), we want to create bounding boxes such that if a ray doesn’t intersect a certain box, we know we don’t need to check in that direction. The BVH construction ends up being a binary tree where we traverse both left and right, but if we don’t intersect the given child, we no longer need to search there. This makes it so that instead of doing an intersection test with every single primitive, we only check primitives that are in bounding boxes the ray passes through. Next, we want to see what the scene looks like with the proper colors. To start, we focus on direct illumination in part 3. The first important thing is zero-bounce illumination where we just display light from the light source. We then want to display the illumination after the first bounce. To do this, we use hemisphere sampling or importance sampling. In hemisphere sampling, we sample rays in all directions from the given point. We then check to see if the outgoing sampled ray intersects anything and check its emittance. If this ends up being something that doesn’t emit light, this sample goes to waste. We need a ton of samples to reduce the noise. Importance sampling is similar except we only sample rays that are from the light directly so that we reduce the amount of wasted samples. If the point we sample is a point light, we only need to sample once since every subsequent sample will be the same. We also avoid casting rays that are behind the surface at a hit point. This leads to importance sampling being much faster along with needing fewer samples to look good. After implementing direct lighting, the scene still doesn’t look quite correct. That is because the light that bounces off the surfaces from the first bounce also emits light. We then need to implement global illumination which continues to include the N subsequent rays resulting from bounces. We achieve this by creating a recursive function that accumulates the values of each bounce and returns once we reach the depth we want. We also implemented the function such that we can see what the scene looks like with just a specific bounce and not the total accumulated. We can never know how many bounces we need for a given scene so we also incorporate Russian Roulette where each bounce only has a certain probability of continuing which gives a good estimate of the global illumination. Finally, not all pixels need the same amount of samples to look good. Some areas converge faster than others which is why we implement adaptive sampling in part 5. Instead of sampling a fixed number of samples, we concentrate samples on areas with higher noise. We instead give an upper limit for samples and essentially follow an algorithm to check whether a pixel has converged or not and return it early if it has. With all of this combined, we have a pathtracer that can render high-quality and precise images.
            </p>
        </section>

        <section id="section1">
            <h2>Part 1: Masses and Springs</h2>
            <p>
                In this part of the project, we constructed a grid of masses and springs. We first determined the dx and dy so that when we iterate over the points for height and width, we evenly spread out the position of each mass pointer properly. If the orientation of the cloth is horizontal, we make the y value of the point masses 1 for all of them. We then make the x position of a given point mass j * dx and the z i * dy. Otherwise, we get a random offset from -1/1000-1/1000 and set the z of the point mass to this. The x stays the same and y is set to i * dy. In both cases, we just emplace_back the current point to the back so it is in row major order. We then iterate over the pinned vector and set the point mass at the given positions to true. For the creation of the springs, we created a helper to check if a given x and y and its added dx and dy values are in bounds of the grid. If not, we do nothing, otherwise we create the spring and add it to our vector. The arguments of the helper are x, y, dx, dy, and spring type. This makes it very easy to iterate over all the points for height and width and just call our helper at the given point with the correct arguments to construct the springs. With this, we have created our grid.
            </p>
        
			<h3>Initial Configuration: KS 5000</h3>
            <div class="image-container">
                <figure>
                    <img src="part1b11.png">
                </figure>
                <figure>
                    <img src="part1b12.png">
                </figure>
                <figure>
                    <img src="part1b13.png">
                </figure>
            </div>

			<h3>Different Constraints</h3>
			<div class="image-container">
                <figure>
                    <img src="part1b21.png">
					<figcaption>No Shearing</figcaption>
                </figure>
                <figure>
                    <img src="part1b22.png">
					<figcaption>With Shearing</figcaption>
                </figure>
                <figure>
                    <img src="part1b13.png">
					<figcaption>All Constraints</figcaption>
                </figure>
            </div>

        </section>

        <section id="section2">
            <h2>Part 2: Simulation via Numerical Integration</h2>
            <p>
                In this part of the project, we began implementing the physics of the cloth interacting with external forces and the spring forces. To calculate the total forces, we simply iterated over all of the external force accelerations and multiplied it by mass, and added this value to a total to get the total external forces. We then set the forces vector of the point mass to equal this total external force. To calculate the spring forces, we simply iterated over the springs and calculated Fs = Ks * (||pa - pb|| - l). We also multiplied the force by 0.2 if it was a bending spring since bending springs should be weaker than structural or shearing. We then multiply the Fs by d.unit() where d = pa - pb, and add it to the a and b mass particle forces making sure to make the a be negative instead to make sure the force of the two points are opposite of each other. For the Verlet integration, we iterated over all of the point masses, and calculated the the xt, vt, and at. Xt is just the position, vt = position - last position, and at is the forces divided by mass. We then apply the formula to update our position, and also make sure to save our previous position in the last_position variable. The new position ends up being xt + (1 - (damping / 100)) * vt + at * delta_t^2. Finally, we want to constrain the position updates to be at most 10% greater than its rest_length at the end of any time step. We did this by iterating over the springs, and first finding the distance between the two point masses of the spring. We then calculated the shift which is the min of 1.1 * rest_length and the norm of the distance, subtracted by the norm of the distance. If both point masses are pinned, we update both points to be half of the shift times the unit of the distance. Otherwise, if one is pinned, we just update the unpinned one to fully have the shift multiplied by the distance unit and the other stays the same.
            </p>
            
            <p>
                Changing the ks value causes the cloth to be much more rigid or droopy. With a really low ks value, the cloth droops down really low and doesn’t flow much when it is dropping. When looking at the final resting state, you can clearly see how much lower it hangs from the two pinned points. With the very high ks value of 100000, it’s almost like a rigid piece of paper just slowly flowing down with near to no creases forming. In the default 5000 ks value, you can clearly see more creases within the cloth and it is wavy when it is falling down. For a low ks value of 100, it definitely has the lowest point as it sags down the most. When it is falling, it seems like it is falling a bit faster and has less flow than 5000. To generalize, the higher the ks value, the more rigid the cloth is.
            </p>

            <div class="image-container">
				<figure>
					<img src="part2ks5000.png">
					<figcaption>Default (KS 5000)</figcaption>
				</figure>
				<figure>
                    <img src="part2ks100.png">
                    <figcaption>KS 100</figcaption>
                </figure>
				<figure>
                    <img src="part2ks100000.png">
                    <figcaption>KS 100000</figcaption>
                </figure>
			</div>
			<p>
                When changing the values for density, a lower density led to a much stiffer cloth, and higher density lead to droopy cloth. When the cloth goes from start to rest with a density value of 1, there is very little creases or wave effects on the cloth as it falls. At the default density of 15, there is more ripples within the cloth as it falls and noticeable creases. Finally for a higher density of 100, more creases form as the cloth is falling and the creases are noticeably deeper compared to the other values. The lower the density, the stiffer the cloth is.
            </p>

            <div class="image-container">
				<figure>
					<img src="part2dens15.png">
					<figcaption>Default (Density 15)</figcaption>
				</figure>
				<figure>
                    <img src="part2dens1.png">
                    <figcaption>Density 1</figcaption>
                </figure>
				<figure>
                    <img src="part2dens100.png">
                    <figcaption>Density 100</figcaption>
                </figure>
			</div>

			<p>
                When changing the values of damping, it changes how much forces affect the cloth. Because damping directly ties to the lost of energy, having 0% damping makes it so the cloth never reaches a resting state and the energy of the forces makes it so the cloth is always swaying and having the ripple effect on the cloth. When you first start the simulation at 0%, the cloth also aggressively swings up down super high and moves quite fast. On the opposite side, having 100% damping causes the cloth to get to rest super slowly, and the cloth doesn’t ripple as it’s approaching the resting state. At the standard of 20%, it has a combination of both described where it falls and ripples as it falls, and isn’t super slow, but also not super fast. Because damping doesn’t relate to the actual physical properties of the cloth, the final resting state will eventually be the same if the damping is not 0%.
            </p>

            <div class="image-container">
				<figure>
					<img src="part2damp20.png">
					<figcaption>Default (Damping 20%)</figcaption>
				</figure>
				<figure>
                    <img src="part2damp0.png">
                    <figcaption>Damping 0%</figcaption>
                </figure>
				<figure>
                    <img src="part2damp100.png">
                    <figcaption>Damping 100%</figcaption>
                </figure>
			</div>
			<h3>Cloth with 4 Pinned Points (Default Settings)</h3>
			<img src="part2pinned4normal2.png" class="solo-image">
        </section>

        <section id="section3">
            <h2>Part 3: Handling Collisions With Other Objects</h2>
            <p>
                Similar to the previous part when varying the ks values, we can see that with higher ks values, the cloth is more rigid and has fewer creases as seen in ks 50000. The lower the ks value, the more the cloth droops as seen in ks 500. When looking at the default ks of 5000, we can see there is a balance between the high and low ks values presented. Because the higher ks value makes the cloth more rigid and has fewer creases, the lowest point of the cloth is also higher than the rest. On the opposite end, the lowest ks valued cloth droops the lowest.
            </p>
        
            <div class="image-container">
                <figure>
                    <img src="part3sphere5000.png">
                    <figcaption>Default (KS 5000)</figcaption>
                </figure>
                <figure>
                    <img src="part3sphere500.png">
                    <figcaption>KS 500</figcaption>
                </figure>
                <figure>
                    <img src="part3sphere50000.png">
                    <figcaption>KS 50000</figcaption>
                </figure>
              
            </div>
      
            <h3>Cloth on Plane</h3>
            <img src="part3planenormal.png" class="solo-image">
        </section>

        <section id="section4">
            <h2>Part 4: Handling Self-Collisions</h2>
            <p>
                In this part of the project, we added self-collisions to the cloth so that the cloth would fold on top of itself rather than clipping through itself. To do this, we began by building a spatial hash map so that we can compare point masses that are close to each other rather than checking a point mass with every other point mass as this is inefficient. We do this by simply defining a hash function to describe where the point mass is, then iterate through all the point masses and insert them into the spatial hash map. To check for self-collisions, we grab the vector of other points within the spatial hash-map using the current point masses hash values and checking if the candidate point mass is within range of our current point mass. We do this by taking the distance of the current position and the position of the candidate point, and checking if the norm is less than or equal to 2 * thickness. If it is, We compute the correction to be (2*thickness - distance.norm()) * distance.unit(). We add this to a total correction vector that includes all of the candidates that are within range. Once we iterate through all of the candidates, we divide the total by the number of candidates we had corrections with and divide by the simulation_steps. We then add this correction to our point mass's current position. When iterating through candidates, we also make sure we don’t try to calculate a correction with ourselves.
            </p>
            <div class="image-container">
                <figure>
                    <img src="part4b11.png">
                </figure>
                <figure>
                    <img src="part4b12.png">
                </figure>
                <figure>
                    <img src="part4b13.png">
                </figure>
                <figure>
                    <img src="part4b14.png">
                </figure>
            </div>
            <p>
                When varying the density of the cloth, we can see the properties of how the cloth folds onto itself. When comparing the lower density to the default, we can see that it has fewer folds on itself, but the folds themselves are much larger. On the opposite end, the largest density has many more folds on itself, but the folds themselves are much smaller. The default cloth is the in-between of the two extremes where it has more folds than the density of 1, but less than the density of 100. The folds are also smaller than the density of 1 but larger than the density of 100. Logically, this makes a lot of sense since when you drop a piece of paper, it has a very small density and doesn’t fold onto itself at all and instead falls flat.
            </p>
            <div class="image-container">
                <figure>
                    <img src="part4density15.png">
                    <figcaption>Default (Density 15)</figcaption>
                </figure>
                <figure>
                    <img src="part4density1.png">
                    <figcaption>Density 1</figcaption>
                </figure>
                <figure>
                    <img src="part4density100.png">
                    <figcaption>Density 100</figcaption>
                </figure>
            </div>
            <p>
                At different levels of ks values, we also see how it changes the amount of folds created as the cloth falls, but also changes the size of the folds. When looking at smaller ks values, we can see that there are many more folds as it falls on itself, but the folds are smaller when comparing them to the default ks value. With larger ks values, we can see there are much fewer folds, but the folds themselves as they form are much larger when the cloth falls on itself. You can also describe them as being much more bendy and wavy in terms of how the folds look because of the stronger springs. To summarize, a larger ks value leads to fewer folds, but the folds are much larger. Inversely, the smaller ks value has many more folds, but the folds themselves are much smaller.
            </p>
            <div class="image-container">
                <figure>
                    <img src="part4ks5000.png">
                    <figcaption>Default (KS 5000)</figcaption>
                </figure>
                <figure>
                    <img src="part4ks100.png">
                    <figcaption>KS 100</figcaption>
                </figure>
                <figure>
                    <img src="part4ks100000.png">
                    <figcaption>KS 100000</figcaption>
                </figure>
            </div>
            
        </section>

        <section id="section5">
            <h2>Part 5: Adaptive Sampling</h2>
            <p>
                We implement adaptive sampling motivated by the fact that certain pixels correspond to parts of the image that converge quicker than others. That means we can get away with sampling fewer rays for those parts without sacrificing much quality. In order to implement it, we keep track of the mean and variance of the illuminance for each pixel in the image after n ray samples (actually, we just keep track of a running sum of the illuminances and a running sum of the squared illuminances and then compute the mean and standard deviation from those). We want to make sure that the variance is sufficiently low to warrant that our estimated illuminance of the pixel is reasonably close to ground truth value with 95% confidence. Every samplesPerBatch number of samples, we check if I <= maxTolerance * mu, where I = 1.96 * sigma / (sqrt(n)) and n is the total number of ray samples we have performed for the pixel so far. If this condition is satisfied, we know that our pixel has converged and we can stop taking more samples. We only perform this check every samplesPerBatch number of samples in order to save computation. 
            </p>
            <div class="image-container">
                <figure>
                    <img src="part5b2Bunny.png">
                    <figcaption>CBbunny</figcaption>
                </figure>
                <figure>
                    <img src="part5b2Bunny_rate.png">
                    <figcaption>CBbunny Rate</figcaption>
                </figure>
                <figure>
                    <img src="part5b2Spheres.png">
                    <figcaption>CBspheres_lambertian</figcaption>
                </figure>
                <figure>
                    <img src="part5b2Spheres_rate.png">
                    <figcaption>CBspheres_lambertian Rate</figcaption>
                </figure>
                <figure>
                    <img src="part5b2Wall-E.png">
                    <figcaption>wall-e</figcaption>
                </figure>
                <figure>
                    <img src="part5b2Wall-E_rate.png">
                    <figcaption>wall-e rate</figcaption>
                </figure>
            </div>
        </section>
        <section id="collab">
            <h2>Collaboration</h2>
            <p>
                Because we are roommates, we were able to pair program very easily throughout the whole project. We would take turns programming on the same device, and bounce ideas off of each other. For the most part, we did all of the parts of the project equally together. There were sections where one partner understood the task at hand more than the other and took charge, but made sure we both understood what was happening by the end of it. With this, we were able to reduce bugs and figure out complex ideas more quickly. We did have issues however when we were both confused and didn't really know how to proceed so we both reinforced the wrong ideas occasionally. This led to us having to redo parts sometimes to fix issues that arose later on. Overall, we were able to learn a lot from each other, and help reduce bugs, especially when it came to technical bugs not related to the assignment such as assigning variables and incrementing. Most importantly, we were able to iron out any confusion either of us had by explaining to one another and reexplaining lecture slides that were relevant. We also learned it was best to work on things together since all of the parts tie closely together so it was crucial we understood every part of the project.
            </p>
        </section>

    </main>
</body>
</html>
